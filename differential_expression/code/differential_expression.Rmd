---
title: "Differential Expression"
author: "Peter Searle"
date: "3/29/2022"
output: html_document
---

# Setup

## Working Directory

The following codes sets the working directory for all subsequent code chunks

```{r setup, include=FALSE, echo=FALSE}

require("knitr")
opts_knit$set(root.dir = "/home/searleps/github/sucker/differential_expression/")

```

## Installation of Miniconda3

```{bash eval=FALSE}
#!/bin/bash
wget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-x86_64.sh
bash Miniconda3-py39_4.9.2-Linux-x86_64.sh 
source ~/miniconda3/bin/activate 
```

# Predict Gene Names

Predict gene names for transcriptomes using EggNOG Mapper.

```{bash}
#!/bin/bash

# Installation

#conda create -n eggnog-mapper
#conda activate eggnog-mapper
#conda install -c bioconda -c conda-forge eggnog-mapper
#mkdir ~/miniconda3/envs/eggnog-mapper/lib/python3.11/site-packages/data
#download_eggnog_data.py

cd ~/github/sucker/differential_expression/data/predicted_genes

for lineage in june utah straw;
do
  mkdir $lineage
  cd $lineage
  mkdir logs
  emapper.py --cpu 20 -o out --data_dir ~/miniconda3/lib/python3.11/site-packages/data \
  --temp_dir ~/github/sucker/differential_expression/data/predicted_genes/${lineage}/ --override \
  -m diamond --dmnd_ignore_warnings -i ../transcriptomes/unfiltered/${lineage}_transcripts.fasta \
  --evalue 0.001 --score 60 --pident 40 --query_cover 20 --subject_cover 20 --itype genome \
  --genepred search --tax_scope 7898 --target_orthologs all --go_evidence non-electronic \
  --pfam_realign none --report_orthologs --decorate_gff yes --excel \
  > ${lineage}/logs/emapper.out 2> ${lineage}/logs/emapper.err
  cd ..
done

```

# Filter Transcriptomes

## Filtered Transcripts .lst File

Generate list of transcripts that are annotated and share gene names across all lineages. 

```{r}
library(tidyverse)
library(dplyr)

fltr_l = list()

for (lineage in c("june", "utah", "straw")) {
  path <- paste0("./data/predicted_genes/", lineage, "/out.emapper.annotations.xlsx")
  fltrd <- readxl::read_excel(path, skip = 2) %>% #skip header lines
    dplyr::rename(query = "query", gene = "Preferred_name", evalue = "evalue", score = "score") %>% #rename columns
    drop_na() %>% select(query, gene, evalue, score) %>% # remove last 3 rows, subset table
    mutate(across('query', str_replace, '_\\d', '')) %>% # remove #'s added by eggnog-mapper to transcripts with multiple hits
    mutate(evalue = as.numeric(evalue)) %>% filter(gene != "-") %>% #remove transcripts without predicted genes
    group_by(query) %>% slice_max(order_by = score) # if transcripts have multiple hits, only retain annotation with highest score
  fltr_l <- append(fltr_l, nrow(fltrd)) # save filtering results 
  dup <- unique(fltrd$gene) %>% toupper() #identify duplicate genes with case differences
  dup <- dup[duplicated(dup)] 
  fltrd$value <- fltrd$gene %in% dup # generate column that identifies if gene is duplicated
  fltrd <- mutate(fltrd, geneF = ifelse(value == TRUE, tolower(gene), gene)) #apply lowercase to duplicated genes only
  newNm <- paste0(lineage, "_fltrd") 
  assign(newNm, fltrd) #assign new name to df
  rm(fltrd, dup, path, newNm, lineage) #cleanup
}

# Common genes between 3 lineages

common_genes <- as_vector(intersect(intersect(june_fltrd$geneF, utah_fltrd$geneF), straw_fltrd$geneF))

# Common transcriptomes

june_final <- filter(june_fltrd, gene %in% common_genes)
utah_final <- filter(utah_fltrd, gene %in% common_genes)
straw_final <- filter(straw_fltrd, gene %in% common_genes)

# Statistics
fltr_rslts <- tibble(Category = "All", June = fltr_l[[1]], Utah = fltr_l[[2]], Straw = fltr_l[[3]])
fltr_rslts <- add_row(fltr_rslts, Category = "Final", June = nrow(june_final), Utah = nrow(utah_final), Straw = nrow(straw_final))
rm(fltr_l)

# Write tables

write.table(common_genes, "./data/predicted_genes/common_genes.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)

path <- "./data/transcriptomes/fltr1/transcript_IDs/"

write.table(june_final$query, paste0(path, "june_transcripts.lst"), row.names = FALSE)
write.table(utah_final$query, paste0(path, "utah_transcripts.lst"), row.names = FALSE)
write.table(straw_final$query, paste0(path, "straw_transcripts.lst"), row.names = FALSE)
```

Modify text in transcripts.lst files so seqtk will run.

```{bash}
#!/bin/bash

cd ~/github/sucker/differential_expression/data/transcriptomes/fltr1/transcript_IDs/

# Remove x and "'s from transcripts.lst 

sed -i 's/x//g' *.lst
sed -i 's/\"//g' *.lst

# Remove blank line at start of file

sed -i '/^$/d' *.lst

# Confirm no duplicate transcripts exist

for file in *.lst;
do
  sort $file | uniq -d
done
```

## Filtered Transcripts .fasta File

Use seqtk to filter assembled transcriptomes using parameters described above. The unfiltered transcriptomes are available in this repository under data/transcriptomes/unfiltered/

```{bash}
#!/bin/bash

#conda create -n seqtk 
#conda install seqtk
#conda install seqkit

conda activate seqtk

cd ~/github/sucker/differential_expression/data/transcriptomes/fltr1/transcript_IDs/

seqtk subseq ../../unfiltered/june_transcripts.fasta june_transcripts.lst > ../filtered_transcripts/june_fltr1.fasta
seqtk subseq ../../unfiltered/utah_transcripts.fasta utah_transcripts.lst > ../filtered_transcripts/utah_fltr1.fasta
seqtk subseq ../../unfiltered/straw_transcripts.fasta straw_transcripts.lst > ../filtered_transcripts/straw_fltr1.fasta
```

## Generate first transcript to gene mapping file

This file is used in the filtering step to associate each transcript with its gene annotation

```{r}
library(tidyverse)

june_tx2gene <- select(june_final, query, geneF)
colnames(june_tx2gene) <- c('txID', 'geneID')

utah_tx2gene <- select(utah_final, query, geneF)
colnames(utah_tx2gene) <- c('txID', 'geneID')

straw_tx2gene <- select(straw_final, query, geneF)
colnames(straw_tx2gene) <- c('txID', 'geneID')

path <- "./data/transcriptomes/fltr1/tx2gene/"

write_tsv(june_tx2gene, paste0(path, "june_tx2gene.tsv"), col_names = T)
write_tsv(utah_tx2gene, paste0(path, "utah_tx2gene.tsv"), col_names = T)
write_tsv(straw_tx2gene, paste0(path, "straw_tx2gene.tsv"), col_names = T)
```

## Final Transcriptomes .fasta File

Additional filtering is required in order to make the transcriptomes comparable among lineages at the transcript-level (i.e. each gene has the same number of transcripts represented for each lineage and each of these transcripts are similar between lineages).

Use seqtk to pull all transcripts annotated as a gene from all lineages and combine into one fasta file

```{bash}
#!/bin/bash

conda activate seqtk

cd ~/github/sucker/differential_expression/data/transcriptomes/fltr2/multi_transcripts/

> logs/seqtk1.log

printf "Extracting transcripts using seqtk for each gene\n" >> logs/seqtk1.log

count=1

cat ../../../predicted_genes/common_genes.txt | while read gene;
do
  printf "Processing $gene $count\n" >> logs/seqtk1.log
  let count++
  > ${gene}.unfltr.fa
  for file in ../../fltr1/tx2gene/*.tsv;
  do
    pattern='\t'"${gene}"'$'
    samp=`basename ${file} _tx2gene.tsv`
    grep -P $pattern $file > gene.txt
    seqtk subseq ../../fltr1/filtered_transcripts/${samp}_fltr1.fasta \
    gene.txt | sed -r 's/(>.+)(\s.+)/\1_'"${samp}"'_'"${gene}"'/g' >> ${gene}.unfltr.fa
    done
    rm gene.txt
done

```

Cluster transcripts associated with each gene using cd-hit-est

```{bash}
#!/bin/bash

#conda create -n cd-hit cd-hit

conda activate cd-hit

> logs/cd_hit_est_1.log

printf "Generating clusters with cd-hit-est\n"

count=1

for file in *.unfltr.fa
do
  gene=`basename ${file} .unfltr.fa`
  printf "Processing $gene $count\n" >> logs/cd_hit_est_1.log
  let count++
  cd-hit-est -i $file -o $gene -c .9 -n 10 -d 100 >> logs/cd_hit_est_2.log
  ~/miniconda3/envs/cd-hit/bin/clstr2txt.pl ${gene}.clstr > ${gene}.clstr.txt
  rm ${gene}.clstr
  rm ${gene}
  mv ${gene}.clstr.txt ${gene}.clstr
done
```

Determine which clusters have all three lineages represented and all transcripts in each cluster with clstr identity >= 97%. If there are multiple instances of transcripts in a cluster from the same lineage, only retain one transcript with highest clstr identity per lineage

```{bash}
#!/bin/bash

#conda create -n pandas pandas

conda activate pandas

> logs/pandas.log

printf "Filtering clusters with python\n" >> logs/pandas.log

count=1

for file in *.clstr
do
  gene=`basename ${file} .clstr`
  printf "Processing $gene $count\n" >> logs/pandas.log
  let count++
  ~/github/sucker/differential_expression/code/cluster.py $file ${gene}.clstr.srtd
done

```

Generate filtered fasta files based off parameters described above 

```{bash}
#!/bin/bash

conda activate seqtk

> logs/seqtk2_1.log
> logs/seqtk2_2.log

printf "Filtering fasta files using seqtk and renaming fasta file headers\n" >> logs/seqtk2_1.log

count=1

for file in *.clstr.srtd;
do
  gene=`basename ${file} .clstr.srtd`
  printf "Processing $gene $count\n" >> logs/seqtk2_1.log
  let count++
  seqtk subseq ${gene}.unfltr.fa ${file} > ${gene}.fltrd1.fa
  seqkit replace -p "^(\S+)" -r '{kv}' -k ${gene}.clstr.srtd ${gene}.fltrd1.fa > ${gene}.fltrd2.fa 2>> logs/seqtk2_2.log
  awk '!/^>/ { printf "%s", $0; n = "\n" } /^>/ { print n $0; n = "" } END { printf "%s", n }' ${gene}.fltrd2.fa > \
  ${gene}.fltrd.fa 
  rm ${gene}.fltrd1.fa
  rm ${gene}.fltrd2.fa
  rm ${gene}.clstr.srtd
  rm ${gene}.unfltr.fa
  rm ${gene}.clstr
done
```

Create final transcriptomes for all three lineages. 

```{bash}
#!/bin/bash

> logs/lineage.log

printf "Generating final transcriptomes\n" >> logs/transcriptomes.log

for lineage in june utah straw;
do
  > ../final_transcripts/${lineage}.fa
done

count=1

for file in *.fltrd.fa
do
  gene=`basename ${file} .fltrd.fa`
  printf "Processing $gene $count\n" >> logs/lineage.log
  let count++
  for lineage in june utah straw;
  do
    grep $lineage $file > gene.txt
    grep -w -f gene.txt -A 1 $file >> ../final_transcripts/${lineage}1.fa
    done
  rm gene.txt
  rm ${gene}.fltrd.fa
done

# confirm no transcripts are represented twice 

cd ../final_transcripts/

grep -o -P '>transcript/\d+' *.fa | uniq -d
```

# Quantify Transcript Abundance with Salmon

```{bash}
#!/bin/bash
source ~/miniconda3/bin/activate 

# Install salmon in its own environment

conda config --add channels conda-forge
conda config --add channels bioconda
conda create -n salmon salmon

# Activate salmon environment

conda activate salmon
```

## Build an Index

Build an index of the transcriptomes before performing transcript-level quantification

```{bash}
#!/bin/bash
source ~/miniconda3/bin/activate
conda activate salmon

cd ~/github/sucker/differential_expression/data/salmon/index/

salmon index -t ~/github/sucker/differential_expression/data/transcriptomes/fltr2/final_transcripts/june.fa -i june_index
salmon index -t ~/github/sucker/differential_expression/data/transcriptomes/fltr2/final_transcripts/utah.fa -i utah_index
salmon index -t ~/github/sucker/differential_expression/data/transcriptomes/fltr2/final_transcripts/straw.fa -i straw_index
```

## Quantify Samples

Salmon then quantifies transcript-level abundance using the index and RNA-seq data. The RNA-seq data is available under BioProject PRJNA818778.

June sucker

```{bash}
#!/bin/bash
source ~/miniconda3/bin/activate
conda activate salmon

for fn in ~/github/sucker/differential_expression/data/rna_seq/june/*_1.fq.gz;
do
  samp=`basename ${fn} _1.fq.gz`
  echo "Processing sample ${samp}"

  dir=`dirname ${fn}`
  echo "${dir}"
  
  salmon quant -i ~/github/sucker/differential_expression/data/salmon/index/june_index -l A \
    -1 $dir/${samp}_1.fq.gz \
    -2 $dir/${samp}_2.fq.gz \
    -p 8 --validateMappings --gcBias \
    -o ~/github/sucker/differential_expression/data/salmon/quant/june/${samp}

done
```

Utah Lake Utah sucker

```{bash}
#!/bin/bash
source ~/miniconda3/bin/activate
conda activate salmon

for fn in ~/github/sucker/differential_expression/data/rna_seq/utah/*_1.fq.gz;
do
  samp=`basename ${fn} _1.fq.gz`
  echo "Processing sample ${samp}"

  dir=`dirname ${fn}`
  echo "${dir}"
  
  salmon quant -i ~/github/sucker/differential_expression/data/salmon/index/utah_index -l A \
    -1 $dir/${samp}_1.fq.gz \
    -2 $dir/${samp}_2.fq.gz \
    -p 8 --validateMappings --gcBias \
    -o ~/github/sucker/differential_expression/data/salmon/quant/utah/${samp}

done
```

Strawberry Reservoir Utah sucker

```{bash}
#!/bin/bash
source ~/miniconda3/bin/activate
conda activate salmon

for fn in ~/github/sucker/differential_expression/data/rna_seq/straw/*_1.fq.gz;
do
  samp=`basename ${fn} _1.fq.gz`
  echo "Processing sample ${samp}"

  dir=`dirname ${fn}`
  echo "${dir}"
  
  salmon quant -i ~/github/sucker/differential_expression/data/salmon/index/straw_index -l A \
    -1 $dir/${samp}_1.fq.gz \
    -2 $dir/${samp}_2.fq.gz \
    -p 8 --validateMappings --gcBias \
    -o ~/github/sucker/differential_expression/data/salmon/quant/straw/${samp}

done
```

# Generate DESeqDataSet

## Generate second transript to gene mapping file

This file is only used in the tximport step if analyses are run at gene instead of transcript-level

```{bash}
#!/bin/bash

cd ~/github/sucker/differential_expression/data/transcriptomes/fltr2/final_transcripts

for file in *.fa;
do
  lineage=`basename ${file} .fa`
  echo $file
  grep ">" ${lineage}.fa | perl -pe 's/>(\w+\/\d+)_(\w+)_(.+)(_)(\d+)/$1_$2_$3$4$5\t$1\t$2\t$3\t$3$4$5/'  > \
  ../tx2gene/${lineage}_tx2gene.fltrd.tsv
done

```

## Generate count matrices at the transcript-level

```{r}
library(tidyverse)

path <- "./data/transcriptomes/fltr2/tx2gene/"

june_tx2gn <- read_delim(paste0(path, "june_tx2gene.fltrd.tsv"), col_names = FALSE)
utah_tx2gn <- read_delim(paste0(path, "utah_tx2gene.fltrd.tsv"), col_names = FALSE)
straw_tx2gn <- read_delim(paste0(path, "straw_tx2gene.fltrd.tsv"), col_names = FALSE)

colnames(june_tx2gn) <- c("txID", "tx", "species", "geneID", "txForm")
colnames(utah_tx2gn) <- c("txID", "tx", "species", "geneID", "txForm")
colnames(straw_tx2gn) <- c("txID", "tx", "species", "geneID", "txForm")

# Check for duplicate transcripts
dup1 <- june_tx2gn$tx[duplicated(june_tx2gn$tx)] 
dup2 <- utah_tx2gn$tx[duplicated(utah_tx2gn$tx)] 
dup3 <- straw_tx2gn$tx[duplicated(straw_tx2gn$tx)] 

june_tx2gene <- select(june_tx2gn, txID, geneID)
utah_tx2gene <- select(utah_tx2gn, txID, geneID)
straw_tx2gene <- select(straw_tx2gn, txID, geneID)

# Determine total # of genes vs. total # of transcripts

df.list <- list(june_tx2gene, utah_tx2gene, straw_tx2gene)

for (df in df.list) {
  len1 <- length(unique(df$geneID))
  len2 <- length(unique(df$txID))
  print(paste("genes:", len1, sep = " "))
  print(paste("transcripts:", len2, sep = " "))
}

# Determine number of transcripts per gene

maxTx <- gsub('transcript/[0-9]+_[a-z]+_[a-zA-Z0-9.-]+_', '', df$txID, perl = TRUE) %>%
  as.numeric() %>% as_tibble() %>% group_by(value) %>% summarise(n = n())

print(maxTx)
```

```{r}
library(readr)
library(tximport)

# Create path to directory including sample files

june_dir <- "./data/sample_info"
utah_dir <- "./data/sample_info"
straw_dir <- "./data/sample_info"

# Manually create and import table with samples and time columns

june_samples <- read.table(file.path(june_dir, "june_samples.txt"), header = TRUE)
utah_samples <- read.table(file.path(utah_dir, "utah_samples.txt"), header = TRUE)
straw_samples <- read.table(file.path(straw_dir, "straw_samples.txt"), header = TRUE)

# Add rownames to samples table

rownames(june_samples) <- june_samples$Sample
rownames(utah_samples) <- utah_samples$Sample
rownames(straw_samples) <- straw_samples$Sample

# Create path to directory including quant.sf files

june_dir <- "./data/salmon/quant/june"
utah_dir <- "./data/salmon/quant/utah"
straw_dir <- "./data/salmon/quant/straw"

# Create a named vector pointing to the quantification files
 
june_files <- file.path(june_dir, june_samples$Sample, "quant.sf")
june_names <- paste0(june_samples$Sample)
names(june_files) <- june_names
print("June Files")
all(file.exists(june_files))

utah_files <- file.path(utah_dir, utah_samples$Sample, "quant.sf")
utah_names <- paste0(utah_samples$Sample)
names(utah_files) <- utah_names
print("Utah Files")
all(file.exists(utah_files))

straw_files <- file.path(straw_dir, straw_samples$Sample, "quant.sf")
straw_names <- paste0(straw_samples$Sample)
names(straw_files) <- straw_names
print("Straw Files")
all(file.exists(straw_files))

# Read in files and generate transcript-level count matrices

june_txi <- tximport(june_files, type = "salmon", txOut = TRUE)
utah_txi <- tximport(utah_files, type = "salmon", txOut = TRUE)
straw_txi <- tximport(straw_files, type = "salmon", txOut = TRUE)

row.names(june_txi$abundance) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(june_txi$abundance), perl = TRUE)
row.names(june_txi$counts) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(june_txi$counts), perl = TRUE)
row.names(june_txi$length) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(june_txi$length), perl = TRUE)

row.names(utah_txi$abundance) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(utah_txi$abundance), perl = TRUE)
row.names(utah_txi$counts) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(utah_txi$counts), perl = TRUE)
row.names(utah_txi$length) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(utah_txi$length), perl = TRUE)

row.names(straw_txi$abundance) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(straw_txi$abundance), perl = TRUE)
row.names(straw_txi$counts) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(straw_txi$counts), perl = TRUE)
row.names(straw_txi$length) <- gsub('transcript/[0-9]+_[a-z]+_', '', row.names(straw_txi$length), perl = TRUE)

# Confirm number of rows is the same between different objects

nrow(june_txi$counts) == 10426
nrow(utah_txi$counts) == 10426
nrow(straw_txi$counts) == 10426
```

## Construct a DESeqDataSet

```{r}
library(DESeq2)

# Set time as factor
june_samples$Time <- factor(june_samples$Time)
utah_samples$Time <- factor(utah_samples$Time)
straw_samples$Time <- factor(straw_samples$Time)

# Generate DESeqDataSet 
june_dds <- DESeqDataSetFromTximport(june_txi,
                              colData = june_samples,
                              design = ~ Time)
utah_dds <- DESeqDataSetFromTximport(utah_txi,
                              colData = utah_samples,
                              design = ~ Time)
straw_dds <- DESeqDataSetFromTximport(straw_txi,
                              colData = straw_samples,
                              design = ~ Time)
```

# Data Transformation and Visualization

## Transformation

Transform count data to aid in visualization 

```{r}
#RLD Transformation
june_rld <- rlog(june_dds, blind=TRUE)
utah_rld <- rlog(utah_dds, blind=TRUE)
straw_rld <- rlog(straw_dds, blind=TRUE)

```

## Visualization with Principal Component Plot

Perform quality assessment of data prior to differential expression analyses. The PCA plot is particularly useful for identifying potential outliers. 

```{r}
library(ggrepel)
library(ggpubr)

june_pca_rld <- plotPCA(june_rld, intgroup="Time") +
  labs(title = "June") +
  theme_bw() +
  theme(plot.title = element_text(hjust = .5, size = 10),
        legend.position = "none", 
        axis.title = element_text(size = 7), 
        axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        )

utah_pca_rld <- plotPCA(utah_rld, intgroup="Time") +
  labs(title = "Utah") +
  theme_bw() +
  theme(plot.title = element_text(hjust = .5, size = 10),
        legend.position = "none", 
        axis.title = element_text(size = 7), 
        axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        )

straw_pca_rld <- plotPCA(straw_rld, intgroup="Time") +
  labs(title = "Strawberry") +
  theme_bw() +
  theme(plot.title = element_text(hjust = .5, size = 10),
        legend.position = "none", 
        axis.title = element_text(size = 7), 
        axis.text = element_text(size = 5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        )

june_pca_rld
utah_pca_rld
straw_pca_rld

PCA_Plot <- ggarrange(june_pca_rld, utah_pca_rld, straw_pca_rld, ncol=1, nrow=3, common.legend = TRUE, legend="bottom")

ggsave("./figures/PCA/PCA.pdf", PCA_Plot, height = 8, width = 4)
```

# Differential Expression Analysis

Run differential expression analysis using DESeq 

```{r}
# Run Differential Expression Analysis

june_dds <- DESeq(june_dds)
utah_dds <- DESeq(utah_dds)
straw_dds <- DESeq(straw_dds)

# Generate DE results by specifying contrast of interest and associated alpha and lfcThreshold values

alpha = .05
lfcThreshold = 0

june_res_12v9 <- results(june_dds, contrast=c("Time","12","9"), alpha = alpha, lfcThreshold = lfcThreshold)
utah_res_12v9 <- results(utah_dds, contrast=c("Time","12","9"), alpha = alpha, lfcThreshold = lfcThreshold)
straw_res_12v9 <- results(straw_dds, contrast=c("Time","12","9"), alpha = alpha, lfcThreshold = lfcThreshold)

june_res_14v9 <- results(june_dds, contrast=c("Time","14","9"), alpha = alpha, lfcThreshold = lfcThreshold)
utah_res_14v9 <- results(utah_dds, contrast=c("Time","14","9"), alpha = alpha, lfcThreshold = lfcThreshold)
straw_res_14v9 <- results(straw_dds, contrast=c("Time","14","9"), alpha = alpha, lfcThreshold = lfcThreshold)

june_res_14v12 <- results(june_dds, contrast=c("Time","14","12"), alpha = alpha, lfcThreshold = lfcThreshold)
utah_res_14v12 <- results(utah_dds, contrast=c("Time","14","12"), alpha = alpha, lfcThreshold = lfcThreshold)
straw_res_14v12 <- results(straw_dds, contrast=c("Time","14","12"), alpha = alpha, lfcThreshold = lfcThreshold)
```

## p-values and adjusted p-values

Summarize basic information with summary function.

```{r}
# Summarize results

summary(june_res_12v9)
summary(utah_res_12v9)
summary(straw_res_12v9)

summary(june_res_14v9)
summary(utah_res_14v9)
summary(straw_res_14v9)

summary(june_res_14v12)
summary(utah_res_14v12)
summary(straw_res_14v12)
```

Check how many samples had adjusted p-values less than alpha, adjusted p-values != NA, and abs(log2fold change) > lfcThreshold?

```{r}
# Adjusted p-values for 12v9 contrast

print("June 12v9")
sum(june_res_12v9$padj < alpha & abs(june_res_12v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("Utah 12v9")
sum(utah_res_12v9$padj < alpha & abs(utah_res_12v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("straw 12v9")
sum(straw_res_12v9$padj < alpha & abs(straw_res_12v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)

# Adjusted p-values for 14v9 contrast

print("June 14v9")
sum(june_res_14v9$padj < alpha & abs(june_res_14v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("Utah 14v9")
sum(utah_res_14v9$padj < alpha & abs(utah_res_14v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("straw 14v9")
sum(straw_res_14v9$padj < alpha & abs(straw_res_14v9$log2FoldChange) > lfcThreshold, na.rm=TRUE)

# Adjusted p-values for 14v12 contrast

print("June 14v12")
sum(june_res_14v12$padj < alpha & abs(june_res_14v12$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("Utah 14v12")
sum(utah_res_14v12$padj < alpha & abs(utah_res_14v12$log2FoldChange) > lfcThreshold, na.rm=TRUE)
print("straw 14v12")
sum(straw_res_14v12$padj < alpha & abs(straw_res_14v12$log2FoldChange) > lfcThreshold, na.rm=TRUE)

```

# Venn Diagrams

Generate Venn Diagrams to visualize transcript expression between contrasts of interest

## Generate List of differentially expressed transcripts

```{r}
# Transcript list for contrast between weeks 12 and 9 (Week 9 is reference)

june_12v9 <- june_res_12v9[which(!is.na(june_res_12v9$padj) & june_res_12v9$padj < alpha & abs(june_res_12v9$log2FoldChange) > lfcThreshold),]@rownames
utah_12v9 <- utah_res_12v9[which(!is.na(utah_res_12v9$padj) & utah_res_12v9$padj < alpha & abs(utah_res_12v9$log2FoldChange) > lfcThreshold),]@rownames
straw_12v9 <- straw_res_12v9[which(!is.na(straw_res_12v9$padj) & straw_res_12v9$padj < alpha & abs(straw_res_12v9$log2FoldChange) > lfcThreshold),]@rownames

all_12v9 <- list(June = june_12v9, Utah = utah_12v9, Strawberry = straw_12v9)

# Transcript list for contrast between weeks 14 and 9 (Week 9 is reference)

june_14v9 <- june_res_14v9[which(!is.na(june_res_14v9$padj) & june_res_14v9$padj < alpha & abs(june_res_14v9$log2FoldChange) > lfcThreshold),]@rownames
utah_14v9 <- utah_res_14v9[which(!is.na(utah_res_14v9$padj) & utah_res_14v9$padj < alpha & abs(utah_res_14v9$log2FoldChange) > lfcThreshold),]@rownames
straw_14v9 <- straw_res_14v9[which(!is.na(straw_res_14v9$padj) & straw_res_14v9$padj < alpha & abs(straw_res_14v9$log2FoldChange) > lfcThreshold),]@rownames

all_14v9 <- list(June = june_14v9, Utah = utah_14v9, Strawberry = straw_14v9)

# Transcript list for contrast between weeks 14 and 12 (Week 12 is reference)

june_14v12 <- june_res_14v12[which(!is.na(june_res_14v12$padj) & june_res_14v12$padj < alpha & abs(june_res_14v12$log2FoldChange) > lfcThreshold),]@rownames
utah_14v12 <- utah_res_14v12[which(!is.na(utah_res_14v12$padj) & utah_res_14v12$padj < alpha & abs(utah_res_14v12$log2FoldChange) > lfcThreshold),]@rownames
straw_14v12 <- straw_res_14v12[which(!is.na(straw_res_14v12$padj) & straw_res_14v12$padj < alpha & abs(straw_res_14v12$log2FoldChange) > lfcThreshold),]@rownames

all_14v12 <- list(June = june_14v12, Utah = utah_14v12, Strawberry = straw_14v12)
```

## Generate Venn Diagrams

```{r}

library(ggplot2)
library(ggVennDiagram)
library(gridExtra)

getVenn <- function(list) {
  
  vennData <- Venn(list) %>% process_data()
  
  myPlot <- ggplot() +
    # 1. region count layer
    geom_sf(aes(fill = count), data = venn_region(vennData)) +
    # 2. set edge layer
    geom_sf(color = "grey", size = 3, data = venn_setedge(vennData),
            show.legend = FALSE) +
    # 3. set label layer
    geom_sf_text(aes(label = name), data = venn_setlabel(vennData)) +
    # 4. region label layer
    geom_sf_label(aes(label = count), data = venn_region(vennData), size = 2) +
    scale_fill_distiller(palette = "Blues", direction = 1) +
    theme_void() +
    theme(legend.position = "none")
  
  return(myPlot)
  
}

venn_12v9 <- getVenn(all_12v9)
venn_14v9 <- getVenn(all_14v9)
venn_14v12 <- getVenn(all_14v12)

myPlot <- grid.arrange(venn_12v9, venn_14v9, venn_14v12, ncol = 1)

ggsave("./figures/venn_diagram/venn_diagrams.pdf", myPlot)

```

# Candidate Transcript Identification

## Geneontology.org

Generate a comprehensive list of candidate transcripts using Geneontology.org.

Navigate to Geneontology.org > Input search terms and search > Select "Annotations" > Select "Custom Download" > Select the following columns of interest: Gene/product (bioentity_label), Gene/product_name (bioentity_name), GO_class (direct) (annotation_class), Contributor (assigned_by), Organism (taxon_label), Evidence (evidence_type), Evidence_with (evidence_with), Reference (reference) and Date (date) > Download and save as .tsv > Input Column names: "Gene	Gene_name	GO_class	Contributor	Organism	Evidence	Evidence_with	Reference	Date."  

## Generate Vectors of Candidate Transcripts

The following code was initially written for analyses at the gene-level, hence the use of gene instead of transcript throughout the following code chunks. The same code applies whether at the gene or transcript-level. 

```{r}

# Generate vector of all transcripts

all_genes <- row.names(june_dds)

# Generate tables of candidate genes from Geneontology.org

# development+face (414)

GO_annot_path1 <- "./data/go_annotations/development+face.tsv"

GO_annot1 <- read_tsv(GO_annot_path1)

# development+craniofacial (645)

GO_annot_path2 <- "./data/go_annotations/development+craniofacial.tsv"

GO_annot2 <- read_tsv(GO_annot_path2)

# Combine tables

GO_annot_combined <- rbind(GO_annot1, GO_annot2)

# Extract unique genes (case insensitive)

GO_genes <- tolower(GO_annot_combined$Gene) %>% unique()

final_genes <- character()

for (gene in GO_genes) {
  pattern <- paste0("^", gene, "_")
  final_genes <- append(grep(pattern, all_genes, value = TRUE), final_genes)
}

```

## Generate Tables of Candidate Transcripts and Expression Levels

These 79 candidate transcripts were then analyzed between the contrasts of 12v9, 14v12 and 14v9 to determine if the gene was upregulated (1), downregulated (-1), unchanged (0) or undetermined (padj = NA). Genes were then removed if their padj equaled NA or if they were in the "0 0 0 0 0 0" category because this indicated the genes were unchanged across all contrasts. After filtering, 50 final candidate transcripts remained.

```{r}

library(nbHelpers)

# Functions

# Create column of expression levels (i.e., upregulated (1), downregulated (-1), unchanged (0)) & NA, and then subset dataframe

candidate_genes <- function(result, final_gene, alpha, lfcThreshold, combo) {
  result <- deseqRes2Tibble(result) %>%
  filter(gene %in% final_gene) %>% 
  mutate(expression = case_when(!is.na(padj) & padj < alpha & log2FoldChange > lfcThreshold ~ 1,
                                !is.na(padj) & padj < alpha & log2FoldChange < -lfcThreshold ~ -1,
                                padj >= alpha ~ 0,
                                padj == NA ~ as.numeric(NA)))
  result <- as.tibble(result[,c(7,8)])
  colnames(result)[2] <- combo
  return(result)
}

# Run candidate transcripts function

# 12v9

june_candidate_12v9 <- candidate_genes(june_res_12v9, final_genes, alpha, lfcThreshold, "J_12v9")
utah_candidate_12v9 <- candidate_genes(utah_res_12v9, final_genes, alpha, lfcThreshold, "U_12v9")
straw_candidate_12v9 <- candidate_genes(straw_res_12v9, final_genes, alpha, lfcThreshold, "S_12v9")

#14v12

june_candidate_14v12 <- candidate_genes(june_res_14v12, final_genes, alpha, lfcThreshold, "J_14v12")
utah_candidate_14v12 <- candidate_genes(utah_res_14v12, final_genes, alpha, lfcThreshold, "U_14v12")
straw_candidate_14v12 <- candidate_genes(straw_res_14v12, final_genes, alpha, lfcThreshold, "S_14v12")

# 14v9

june_candidate_14v9 <- candidate_genes(june_res_14v9, final_genes, alpha, lfcThreshold, "J_14v9")
utah_candidate_14v9 <- candidate_genes(utah_res_14v9, final_genes, alpha, lfcThreshold, "U_14v9")
straw_candidate_14v9 <- candidate_genes(straw_res_14v9, final_genes, alpha, lfcThreshold, "S_14v9")

# Join Dataframes

# 12v9

candidate_expression_combined_12v9 <- full_join(full_join(june_candidate_12v9, utah_candidate_12v9, by = "gene"), straw_candidate_12v9, by = "gene")

# 14v12

candidate_expression_combined_14v12 <- full_join(full_join(june_candidate_14v12, utah_candidate_14v12, by = "gene"), straw_candidate_14v12, by = "gene")

# 14v9

candidate_expression_combined_14v9 <- full_join(full_join(june_candidate_14v9, utah_candidate_14v9, by = "gene"), straw_candidate_14v9, by = "gene")

# Combine 12v9, 14v9, & 14v12 data frames together

candidate_expression_combined <- full_join(candidate_expression_combined_14v9,
                                           full_join(candidate_expression_combined_12v9,
                                                     candidate_expression_combined_14v12,
                                                     by = "gene"), by = "gene")

# Remove any transcripts that have an NA for their padj from all time combinations (12v9, 14v12, 14v9).

candidate_expression_combined <- drop_na(candidate_expression_combined)

# Generate combo column with expression combinations of each transcript (i.e., 0 0 0 0 0 1 = Upregulated in straw in 14v12, unchanged for all other species and times) in 12v9 and 14v12 contrasts.

candidate_expression_combined$combo <- paste(candidate_expression_combined$J_12v9, 
                                        candidate_expression_combined$U_12v9,
                                        candidate_expression_combined$S_12v9,
                                        candidate_expression_combined$J_14v12,
                                        candidate_expression_combined$U_14v12,
                                        candidate_expression_combined$S_14v12)

# Generate counts of expression combinations to explore clustering of transcripts 

candidate_expression_counts <- dplyr::count(candidate_expression_combined, combo)

# Pull genes from specific expression combinations of interest

check <- filter(candidate_expression_combined, combo == "0 0 0 0 0 1") %>% select(gene) %>% pull(gene)

# Look at p-value for specific transcript. This can be useful to confirm that other functions are working appropriately. 

genePvalue <- deseqRes2Tibble(straw_res_14v12) %>% filter(gene == "ski_1")
```

# Candidate Transcript Plots

## Plot Counts

Generate normalized counts using plotCounts() and then generate plots from these data using ggplot2 for all differentially expressed transcripts

```{r}
library(tidyverse)
library(DESeq2)
library(ggpubr)
library(grid)
library(gridExtra)
library("ggprism")
library("scales")

# Functions

# Determine significance of gene for one species at one time point and store in table

pValue <- function(res, gene) {

  # Filter out data for gene of interest  
  
  p <- as.data.frame(res) %>% rownames_to_column(var = "Gene") %>% filter(Gene == gene)
  
  # Select columns of interest 
  
  p <- p[,c(1,7)]
  
  # Generate new column of significance (i.e. NA, "" = ns, *, **, ***, ****)
  
  p <- mutate(p, signif = case_when(padj >= .05 ~ "", 
                                    padj == NA ~ as.character(NA),
                                    padj < .05 & padj >= .01 ~ "*", 
                                    padj < .01 & padj >= .001 ~ "**",
                                    padj < .001 & padj >= .0001 ~ "***",
                                    padj < .0001 ~ "****",))
  
  # Extract time information from name of data frame and store as string
  
  str1 <- deparse(substitute(res))
  str1 <- gsub('.+_.+_(.+)','\\1',str1)
  time <- c(str1)
  
  # Extract species information from name of data frame and store as string
  
  str2 <- deparse(substitute(res))
  str2 <- gsub('(.+)_.+_.+','\\1',str2)
  species <- c(str2)

  # Add time and species columns

  p <- add_column(p, time, species)

  return(p)

}

# Combine significance data frames 

pValue_Combo <- function(june_res_12v9, utah_res_12v9, straw_res_12v9, 
                         june_res_14v12, utah_res_14v12, straw_res_14v12, 
                         june_res_14v9, utah_res_14v9, straw_res_14v9, gene) {
  
  # Determine significance of gene for one species at one time point and store in table
  
  p1 <- pValue(june_res_12v9, gene)
  p2 <- pValue(utah_res_12v9, gene)
  p3 <- pValue(straw_res_12v9, gene)
  p4 <- pValue(june_res_14v12, gene)
  p5 <- pValue(utah_res_14v12, gene)
  p6 <- pValue(straw_res_14v12, gene)
  p7 <- pValue(june_res_14v9, gene)
  p8 <- pValue(utah_res_14v9, gene)
  p9 <- pValue(straw_res_14v9, gene)

  # Generate Time1, Time2 columns for brackets in ggplot code below
  
  p_combo <- rbind(p1, p2, p3, p4, p5, p6, p7, p8, p9) %>% as_tibble() %>% 
    mutate(Time1 = case_when(time == "12v9" ~ 1, 
                             time == "14v9" ~ 1, 
                             time == "14v12" ~ 2)) %>%
    mutate(Time2 = case_when(time == "12v9" ~ 2, 
                             time == "14v9" ~ 3, 
                             time == "14v12" ~ 3)) 
  
  return(p_combo)
}

# Generate plot of transcript counts for transcript of interest

gene_counts <- function(j_dds, u_dds, s_dds, gene_name, significance) {
 
  # Dataframe of plot counts for points
  
  j_gene <- plotCounts(j_dds, gene = gene_name, intgroup = c("Time"), returnData = TRUE)
  j_gene <- data.frame(j_gene, species = c("June"))
  
  u_gene <- plotCounts(u_dds, gene = gene_name, intgroup = c("Time"), returnData = TRUE)
  u_gene <- data.frame(u_gene, species = c("Utah"))
  
  s_gene <- plotCounts(s_dds, gene = gene_name, intgroup = c("Time"), returnData = TRUE)
  s_gene <- data.frame(s_gene, species = c("Strawberry"))
  
  # Data frame of average counts for line
  
  j_average <- as_tibble(j_gene) %>% group_by(Time) %>% summarise(average = mean(count)) 
  j_average <- data.frame(j_average, species = c("June"))

  u_average <- as_tibble(u_gene) %>% group_by(Time) %>% summarise(average = mean(count)) 
  u_average <- data.frame(u_average, species = c("Utah"))

  s_average <- as_tibble(s_gene) %>% group_by(Time) %>% summarise(average = mean(count))
  s_average <- data.frame(s_average, species = c("Strawberry"))

  # Data frame of significance for each species
  
  significance <- mutate(significance, species = case_when(species == "june" ~ "June",
                                                           species == "utah" ~ "Utah",
                                                           species == "straw" ~ "Strawberry"))

  j_significance <- filter(significance, species == "June")
  u_significance <- filter(significance, species == "Utah")
  s_significance <- filter(significance, species == "Strawberry")
  
  # Merge plot counts data frames together
  
  counts <- rbind(j_gene, u_gene, s_gene)
  
  # Refactor species column so order is displayed correctly in legend
  
  counts$species <- factor(counts$species, levels = c("June", "Utah", "Strawberry"))
  
  # Merge average counts data frames together
  
  average <- rbind(j_average, u_average, s_average)
  average <- dplyr::rename(average, time = Time)
  
  # Refactor species column so order is displayed correctly in legend
  
  average$species <- factor(average$species, levels = c("June", "Utah", "Strawberry"))
  
  # Generate plot of counts
  
  ggplot(counts, aes(x = Time, y = count, color = species)) + 
    geom_point(position = position_jitter(w = 0.1, h = 0), size = .5) +
    geom_line(average, mapping = aes(x = time, y = average, group = species)) +
    scale_y_log10(limits = c(NA, 7*max(counts$count))) +
    scale_colour_discrete("Species") +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          plot.title = element_text(hjust = 0.5, size = 6), axis.title.x = element_blank(),
          axis.title.y = element_blank(), axis.text.x = element_text(size = 5),
          axis.text.y = element_text(size = 5)) +
    ggtitle(gene_name) +
    add_pvalue(j_significance, label = "signif", xmin = "Time2", xmax = "Time1", 
               y.position = log10(1.5*max(counts$count)), tip.length = .01, step.increase = 0.06,
               label.size = 4, bracket.color = "black") +
    add_pvalue(u_significance, label = "signif", xmin = "Time2", xmax = "Time1", 
               y.position = log10(1.55*max(counts$count)), tip.length = .01, step.increase = 0.06,
               label.size = 4, bracket.color = "transparent") +
    add_pvalue(s_significance, label = "signif", xmin = "Time2", xmax = "Time1", 
               y.position = log10(1.65*max(counts$count)), tip.length = .01, step.increase = 0.06,
               label.size = 4, bracket.color = "transparent") 
}

# Some of the plots display in scientific notation. This will set a higher penality for deciding to use scientific notation
options(scipen=10000)

# Generates plots of all differentially expressed genes

multiGene_plot <- function(interest, str1) {
  
  gene_list <- list()
    
  # Generate list of plots from expression combination of interest 

  for (i in interest) {
    pValue_Final <- pValue_Combo(june_res_12v9, utah_res_12v9, straw_res_12v9,
                           june_res_14v12, utah_res_14v12, straw_res_14v12,
                           june_res_14v9, utah_res_14v9, straw_res_14v9, i)

    # Make sure genes that equal NA are not plotted
    
    if (!any(is.na(pValue_Final$signif))) {
      gene_plot <- gene_counts(june_dds, utah_dds, straw_dds, i, pValue_Final)
      gene_list[[i]] <- gene_plot
    }
  }
  
  # If go back to all 50 on one page, make list into a nested list so mmarrange will work
  
    figlist <- ggarrange(plotlist = gene_list, ncol=5, nrow=5, common.legend = TRUE, legend="bottom") 
    final_pdf <- marrangeGrob(figlist, nrow = 1, ncol = 1, left = "Counts", bottom = "Time", top = NULL)
    pdf_name <- paste("./figures/counts/", str1, ".pdf", sep ="")
    pdf_name <- gsub(" ", "", pdf_name)   
    ggsave(file = pdf_name, final_pdf, width = 8.5, height = 11, units = "in") 
  
}

# Remove candidate transcripts that were not differentially expressed for all time points

plotCombo <- filter(candidate_expression_combined, combo != "0 0 0 0 0 0") %>%
  select(gene) %>% pull(gene)

multiGene_plot(plotCombo, "all_transcripts")

```
